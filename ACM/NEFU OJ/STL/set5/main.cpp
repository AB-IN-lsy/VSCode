#include <bits/stdc++.h>
using namespace std;
set<int> s;
int main()
{
    int n;
    scanf("%d", &n);
    int cnt = 0;
    int las = -1;//由于0位起始所以las的初始值要设为0-1
    int tmp = 0;
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &tmp);
        while (s.count(tmp))//做等效的加法来过滤相同元素
        {
            s.erase(tmp);
            tmp++;
        }
        s.insert(tmp);
    }
    for (set<int>::iterator iter = s.begin(); iter != s.end(); iter++)//预处理完成，开始遍历操作
    {
        cnt += (*iter - las - 1);
        las = *iter;
    }
    printf("%d",cnt);
    return 0;
}
/*简单分析一下， 2x 的二进制形式是000001000000（打个比方），而 2v−1 的形式也是非常有特点00001111111111（打个比方），而想要得到这样的形式我们可以简单地理解成将空填满，需要补的 2x 正是填满他们的“原料”。

如果拆烂了来说就是我们输入的n个数各自填满了所在的位置，我们需要给出从最大的那个数到0之间有多少个0没被填充即可。

有的人可能会第一反应想到map，利用map去像处理一个二进制数一样去处理，最后遍历得到0的个数，这么做当然可以，只是时空复杂度相比我们这种做法不占优势。而且浪费了一个非常好的性质，他是有序输入的！

我们先把题目放宽一些，改成序列严格单调增加，我们会得到一个有趣的性质，各个 2x 之间并没有必然的联系，也就是说我们输入到第k位的时候其实前k−1位都具体的确定了下来，而 2k 与 2k−1 之间的位置则全部是0。这就非常好了，我们就可以在O(n)的时间内完成这项查找。

然而这个题目多了一点就是输入数据会有相同的点。而这种情况我们则恰恰可以利用set的去重性质去处理，两个 2k 相加我们就会得到一个 2k+1 。如此一来，代码便顺理成章了。*/
